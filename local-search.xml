<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2022/11/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2022/11/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>本文梳理了6种常见排序算法：冒泡、计数、快速、归并、插入、选择</p><p>时间复杂度如下：</p><p><img src="https://user-images.githubusercontent.com/34484322/89124140-33df9700-d507-11ea-8c67-05d51e8103d6.png"></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><strong>「时间复杂度O(n*n)」</strong></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="https://user-images.githubusercontent.com/34484322/89124183-9e90d280-d507-11ea-9f3b-b486f792aa2d.gif"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li><p>比较相邻的元素，前者比后者大的话，两者交换位置。</p></li><li><p>对每一对相邻元素做相同操作，从开始第一对到最后一对，这样子最后的元素就是最大元素。</p></li><li><p>针对n个元素重复以上步骤，每次循环排除当前最后一个。</p></li><li><p>重复步骤1~3，直到排序完成。</p></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 最外层循环控制的内容是循环次数</span><br><span class="hljs-comment">// 每一次比较的内容都是相邻两者之间的大小关系</span><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">BubbleSort</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">arr, flag = <span class="hljs-number">0</span></span>) &#123;<br>    <span class="hljs-keyword">let</span> len = arr.<span class="hljs-property">length</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>                [arr[j], arr[j + <span class="hljs-number">1</span>]] = [arr[j + <span class="hljs-number">1</span>], arr[j]]<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> flag ? arr.<span class="hljs-title function_">reverse</span>() : arr<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>每轮记录最小的那个值与arr[i]进行互换</p><p><strong>「时间复杂度O(n*n)」</strong></p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p><img src="https://user-images.githubusercontent.com/34484322/89124365-0398f800-d509-11ea-9573-6a24820cfd81.gif"></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li><p>有n个数,需要排序n-1次</p></li><li><p>第一次选择最小值,放在第一位</p></li><li><p>第二次选择最小值,放在第二位</p></li><li><p>…..重复该过程</p></li><li><p>第n-1次选择最小值,放在第n-1位</p></li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> selectSort = <span class="hljs-keyword">function</span> (<span class="hljs-params">arr, flag = <span class="hljs-number">0</span></span>) &#123;<br>    <span class="hljs-keyword">let</span> len = arr.<span class="hljs-property">length</span>,<br>        temp = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 一共需要排序len-1次</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;<br>        temp = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; len; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[temp])<br>                temp = j;<br>        &#125;<br>        <span class="hljs-comment">// 每一趟保证第i位为最小值</span><br>        <span class="hljs-keyword">if</span> (temp !== i) &#123;<br>            [arr[i], arr[temp]] = [arr[temp], arr[i]]<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> flag ? arr.<span class="hljs-title function_">reverse</span>() : arr<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sortMin</span>([<span class="hljs-number">76</span>,<span class="hljs-number">34</span>,<span class="hljs-number">3</span>,<span class="hljs-number">46</span>,<span class="hljs-number">1</span>,<span class="hljs-number">22</span>,<span class="hljs-number">45</span>,<span class="hljs-number">31</span>]));<br></code></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p><strong>「时间复杂度: O(n*n)」</strong></p><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p><img src="https://user-images.githubusercontent.com/34484322/89124203-c2541880-d507-11ea-9859-e964f5463a86.gif"></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li><p>从第一个元素开始，该元素可以认为已经被排序；</p></li><li><p>取出下一个元素，在已经排序的元素序列中从后向前扫描；</p></li><li><p>如果该元素（已排序）大于新元素，将该元素移到下一位置；</p></li><li><p>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</p></li><li><p>重复步骤2~5。</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> insertionSort = <span class="hljs-keyword">function</span> (<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">let</span> len = arr.<span class="hljs-property">length</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">let</span> preIndex = i - <span class="hljs-number">1</span>,<br>            cur = arr[i];<br>        <span class="hljs-keyword">while</span> (preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[preIndex] &gt; cur) &#123;<br>            arr[preIndex + <span class="hljs-number">1</span>] = arr[preIndex]<br>            preIndex--;<br>        &#125;<br>        arr[preIndex + <span class="hljs-number">1</span>] = cur<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>将两个有序数列合并成一个有序数列，我们称之为“归并”</p><p>基本思想与过程：先递归的分解数列，再合并数列（分治思想的典型应用）</p><p><strong>「时间复杂度: O(nlog(n))」</strong></p><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p><img src="https://camo.githubusercontent.com/4087941af1ad827c4878739509716df32168e1fb/68747470733a2f2f706963342e7a68696d672e636f6d2f76322d63646461336631316336656662633031353737663563323961393036363737325f622e77656270"></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>将一个数组拆成A、B两个小组，两个小组继续拆，直到每个小组只有一个元素为止。按照拆分过程逐步合并小组，由于各小组初始只有一个元素，可以看做小组内部是有序的，合并小组可以被看做是合并两个有序数组的过程。对左右两个小数列重复第二步，直至各区间只有1个数。</p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 归并</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeSort</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr;<br>    <span class="hljs-keyword">let</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(arr.<span class="hljs-property">length</span> / <span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">let</span> merge = <span class="hljs-keyword">function</span> (<span class="hljs-params">leftArr, rightArr</span>) &#123;<br>        <span class="hljs-keyword">let</span> resultArr = [];<br>        <span class="hljs-keyword">while</span>(leftArr.<span class="hljs-property">length</span> &amp;&amp; rightArr.<span class="hljs-property">length</span>) &#123;<br>            resultArr.<span class="hljs-title function_">push</span>(leftArr[<span class="hljs-number">0</span>] &lt;= rightArr[<span class="hljs-number">0</span>] ? leftArr.<span class="hljs-title function_">shift</span>() : rightArr.<span class="hljs-title function_">shift</span>())<br>        &#125;<br>        <span class="hljs-keyword">return</span> resultArr.<span class="hljs-title function_">concat</span>(leftArr).<span class="hljs-title function_">concat</span>(rightArr);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">merge</span>(<span class="hljs-title function_">mergeSort</span>(arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, mid)), <span class="hljs-title function_">mergeSort</span>(arr.<span class="hljs-title function_">slice</span>(mid)))<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p>通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><p><strong>「时间复杂度：O(nlogn)」</strong></p><h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><p><img src="https://user-images.githubusercontent.com/34484322/89124218-e0ba1400-d507-11ea-87f1-d14ae3aadfb0.gif"></p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><ol><li><p>选择数组中间数作为基数，并从数组中取出此基数</p></li><li><p>准备两个数组容器，遍历数组，逐个与基数比对，较小的放左边容器，较大的放右边容器；</p></li><li><p>递归处理两个容器的元素，并将处理后的数据与基数按大小合并成一个数组，返回。</p></li></ol><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 快排 nlogn</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">quickSort</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span> &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> arr;<br><br>    <span class="hljs-keyword">let</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(arr.<span class="hljs-property">length</span> / <span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">let</span> pivot = arr.<span class="hljs-title function_">splice</span>(mid, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>];<br><br>    <span class="hljs-keyword">let</span> left = [];<br>    <span class="hljs-keyword">let</span> right = [];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i] &lt; pivot) &#123;<br>            left.<span class="hljs-title function_">push</span>(arr[i])<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right.<span class="hljs-title function_">push</span>(arr[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">quickSort</span>(left).<span class="hljs-title function_">concat</span>(<span class="hljs-title function_">quickSort</span>([pivot].<span class="hljs-title function_">concat</span>(right)))<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>把数组元素作为数组的下标，然后用一个临时数组统计该元素出现的次数。</p><p>数组的数据必须是整数，而且最大最小值相差的值不要过大，对于**「数据是负数的话，我实现的方案对此有优化」**。</p><p><strong>「时间复杂度：O(n+k)」</strong></p><h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h3><p><img src="https://user-images.githubusercontent.com/34484322/89124171-815c0400-d507-11ea-9b77-e45ea157a96d.gif"></p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><ol><li><p>计算出差值d,最小值小于0,加上本身add</p></li><li><p>创建统计数组并统计对应元素个数</p></li><li><p>统计数组做变形，后面的元素等于前面的元素之和,也就是排名数组</p></li><li><p>遍历原始数组,从统计数组中找到正确位置,输出到结果数组</p></li></ol><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 计数排序</span><br><span class="hljs-keyword">let</span> countingSort = <span class="hljs-keyword">function</span>(<span class="hljs-params">arr, flag = <span class="hljs-number">0</span></span>) &#123;<br>    <span class="hljs-keyword">let</span> min = arr[<span class="hljs-number">0</span>],<br>        max = arr[<span class="hljs-number">0</span>],<br>        len = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-comment">// 求最大最小值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        max = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(arr[i], max)<br>        min = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(arr[i], min)<br>    &#125;<br>    <span class="hljs-comment">// 1.计算出差值d,最小值小于0,加上本身add</span><br><br>    <span class="hljs-keyword">let</span> d =  max - min,<br>        add = min &lt; <span class="hljs-number">0</span> ? -min : <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//2.创建统计数组并统计对应元素个数    </span><br>    <span class="hljs-keyword">let</span> countArray  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(d+<span class="hljs-number">1</span>+add).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>        <span class="hljs-keyword">let</span> demp = arr[i]- min + add<br>        countArray[ demp ] += <span class="hljs-number">1</span> <br>    &#125;<br>    <br>    <span class="hljs-comment">//3.统计数组做变形，后面的元素等于前面的元素之和,也就是排名数组</span><br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 这里需要遍历的是countArray数组长度</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; d+<span class="hljs-number">1</span>+add; i++)&#123;<br>        sum += countArray[i]<br>        countArray[i] = sum;<br>    &#125;<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(len)<br>    <span class="hljs-comment">// 4.遍历原始数组,从统计数组中找到正确位置,输出到结果数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>        <span class="hljs-keyword">let</span> demp = arr[i] -min + add<br>        res[ countArray[demp] -<span class="hljs-number">1</span> ] = arr[i]<br>        countArray[demp] --;<br>    &#125;<br>    <span class="hljs-keyword">return</span> flag ? res.<span class="hljs-title function_">reverse</span>() : res<br>&#125;<br><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">2</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">countingSort</span>(arr))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
